/*
 * CTD Aanderaa
 NE MARCHE PAS ENCORE
 */

// ---------------------   PARAMETRES MODIFIABLE DU PROGRAM    -----------------------------------
// Version et numero de serie
String fichier_config = "/config.txt";   // nom du fichier de configuration
String dataFilename = "/datalog.txt";        // nom du fichier de données
char versoft[] = "1.0";                  // version du code pour littobs 2.2 et 2.3 et 2.5 (attention 2.5 il faut modifier la pin de control 5V pour la pin 14)
// --------------------     FIN DES PARAMETRES MODIFIABLES     -----------------------------------


//déclaration des librairies
//#include <Arduino.h>
#include <WiFi.h>
#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>
#include "FS.h"
#include <Wire.h>                       // enable I2C
#include <DS3231.h>                     // Pour horloge RTC
#include "SPI.h"                        // pour connection ecran bus SPI
#include <SD.h>                         // pour carte SD
#include "MS5837.h"                   // pour capteur de pression blue robotics BAR30
#include "TSYS01.h"                     // capteur de températuer rapide et précis
#include <HardwareSerial.h>             // pour capteur serie fluo

// SERVER PARAMETER
const char *ssid = "LittObs-instrument";    // SSID Name generated by ESP32
//const char *password = "123456789";       //if comment,  no password required
AsyncWebServer server(80);  // Create AsyncWebServer object on port 80

const char* PARAM_INPUT_1 = "input1";
const char* PARAM_INPUT_2 = "input2";

String inputMessage;
String inputParam;
String delayValue;
String debugValue;
String ledValue;
String nbrValue;


// déclaration pour gestion des Led et interrupteur
const int greenled = 9;               // Led for information
const int serverpin= 15;                // Pin with reed magnet switch for server start
const int start12v = 27;             // pin qui controle l'allumage du régulateur 12v pour alimenter capteur Aanderaa et Led UV


//déclaration pour capteur de pression et température de chez Blue robotic
MS5837 sensor_bar30;
TSYS01 sensor_fastTemp;
float  wat_pressure, wat_temp, wat_depth, alt, fast_temp;

// déclaration pour capteur rs232 et fonction de parsing 
#define RXD1 16 //25
#define TXD1 17 //26
HardwareSerial Serial_fluo(1);             // si 25/26 alors Serial2(2), et modifier tout les Serial_fluo par Serial2.
String dataserial,fluochain, full_serialFinal, short_serialFinal;               // fluochain = a                                           
const char marqueurDeFin = '\r';
int c;
int StartStock = 0;
String DATAIN;

//RTC definition
DS3231 Clock;
bool Century = false;
bool h12;
bool PM;
String second, minute, hour, date, month, year;
String datenum, timenum, datetime;                   // pour format de date en 1 seule écriture


// déclaration pour la gestion de fichier sur la carte SD et fichier config
String datachain = "";                   // chaine de donnée texte de mesure
const int cspin_SD=5;
String filename_temp, str_index, filetrans;
int ind;                      // index vérification de fichier
//fichier config
String id_logger, number_measures, delay_batch, led_mode_sd, debug_mode_sd ,clef_test;
File confFile; 



// definition pour la fonction deepsleep de l'ESP32
#define uS_TO_S_FACTOR 1000000      // Conversion factor for micro seconds to seconds
RTC_DATA_ATTR int bootCount = 0;    // utile pour enregistrer un compteur dans la memoire rtc de l'ULP pour un compteur permettant un suivi entre chaque veille
RTC_DATA_ATTR int TIME_TO_SLEEP = 10;          // Durée d'endormissement entre 2 cycles complets de mesures (in seconds) par défault 600 (mais rédéfinie par le fichier config)
int nbrMes = 3;         // valeur initiale par défault en cas de default de lecture du fichier config

//  mode de fonctionnement, valeur par défault en cas de de defaut de lecture du fichier config
int led_mode = 1;        // utilise la Led pour controler ce qui se passe
int debug_mode = 1;      // envoi les infos sur les liaison serie

// int delayBatch = 10; //in second









void setup() {
  // ------------------           SETUP (run loop, and what we need for each loop)    ------------------------------------------
  // ------------------        HERE IS NEEDED THE PARAMETER FOR THE ENTIER PROGRAMM   ------------------------------------------

      if(debug_mode==1) Serial.begin(115200);                             // communication avec le PC
      
      // initiate pin
      pinMode(greenled, OUTPUT);                                          // initiate light
      pinMode(start12v, OUTPUT);                                          // pin for Anderaa sensors
      pinMode(serverpin, INPUT_PULLUP);                                   // intitiate Pin for server

      // Wakeup and power on sensors, pin, SD etc....
      if (debug_mode==1) Serial.println("------ WAKE UP AND START Measures ---------"); 
      if (led_mode==1) digitalWrite(greenled, HIGH);                      // mean wake up and start measures
      digitalWrite(start12v, HIGH);                                       //power on conductivity sensors
      delay(300);                                                         //few time to let the sensors and SD module start correctly

      // starting I2C communication
      Wire.begin();                                                       // initiate I2C communication

      // starting Serial communication for RS232 sensors
      DATAIN.reserve(32);
      Serial_fluo.begin(9600, SERIAL_8N1, RXD1, TXD1); // communication serie avec la sonde de fluo

      // initialisation sensors
      sensor_fastTemp.init();                                             // initiate bluerobotics température sensors
      sensor_bar30.init();                                                // initiate BlueRobotics Pressure Sensors          

      // test & initialise SD card
      test_sd();                                                          // test if SD is present and ok
      delay(300);                                                         // delay pour eviter les ecriture trop rapide sur la carte SD en cas de faux contact à l'allumag et laisser le temps au autre composant (atlas de s'allumer correctement)
     

       
  if(bootCount == 0){
  // --------------        HERE IS ONLY THE INTRODUCION           -----------------------------------------------------------
  // -------------- run just once at the startup, and ignore at each loop ---------------------------------------------------

      // read values on configuration file, and store data into variable   
        // read config file
        lecture_config();
        // reattribute values on SRAM variables thanks to file :  config.txt
        TIME_TO_SLEEP=delay_batch.toInt();         // en s
        nbrMes=number_measures.toInt();            
        debug_mode=debug_mode_sd.toInt();  
        led_mode=led_mode_sd.toInt();  


      // if magnet is detected start the web server and stop the programm here
        if(digitalRead(serverpin)==LOW){
          blinkled(8,150);
          digitalWrite(greenled, HIGH);
          Serial.println("Server mode");
          serveur();
          while(1){};
        }
      
      //Create and Write the 1st ligne of the CSV file
        String datachain = "";
        datachain += "Date & heure"; datachain += ";"; 
        for(int n=1; n<=nbrMes; n++){
          datachain += "Profondeur(m)"; datachain += ";"; 
          //datachain += "Temperature mer (C)"; datachain += ";"; 
          datachain += "Conductivity"; datachain += ";"; 
          datachain += "Temperature"; datachain += ";";
          //datachain += "Salinity"; datachain += ";";
        }
    
      // save the datachain on the SD card
        File dataFile = SD.open(dataFilename, FILE_APPEND);       // FILE_APPEND pour esp32, FILE_WRITE pour arduino
        if (dataFile) {                                        // if the file is available, write to it:
          dataFile.println(datachain);
          dataFile.close();
          if (debug_mode==1) Serial.println("Fichier créer avec succes");
          if (debug_mode==1) {Serial.print("Filename : "); Serial.println(dataFilename);}
        }
        else {                                                 // if the file isn't open, pop up an error:
          if (debug_mode==1) Serial.println("error opening file");
          for (int i=0; i<=5; i++){
              errormessage_sd();
          }
        }

      // Sleeping of sensors, pin and other...
        all_sleep();

      bootCount = bootCount+1;   // changement du numéro de compteur pour passer directement dans programm loop apres le reveil
  
  }
  else{
  // ---------------        HERE IS THE MAIN PROGRAMM LOOP         ----------------------------------------------------------
  // ---------------         Programm run at each loop             ----------------------------------------------------------

      if(debug_mode==1) Serial.println("Temps de chauffe du capteur rs232 ...");
      delay(5000); // pour laisser le capteur aanderaa se mettre en chauffe
      
      // read values on configuration file, and store data into variable
        // read config file
          lecture_config();
        // reattribute values on SRAM variables thanks to file :  config.txt
          TIME_TO_SLEEP=delay_batch.toInt();         // en s
          nbrMes=number_measures.toInt();            
          debug_mode=debug_mode_sd.toInt();  
          led_mode=led_mode_sd.toInt();   

      // Read all sensors     
        lecture_rtc();               // read RTC Sensors just once

        // Creating new datachain to store sensors values
        String datachain = "";                                  // initiate datachain a empty values
        datachain += datetime; datachain += ";";                // store date and time on datachain
            
        //read sensors several times and add values to datachain
        for(int n=1; n<=nbrMes; n++){
          mesure_pressure();
            datachain += wat_depth; datachain += ";"; 
            // datachain += wat_temp; datachain += ";";    // si température du capteur Bar30 requise
          //mesure_temp();
            //datachain += fast_temp; datachain += ";";
          mes_serial_sensor();             // read rs232 data 
          parse_serial_data();             // parsing of rs232 value (for logging on SD or manipulate date)
            datachain += short_serialFinal; datachain += ";"; 
            //datachain += Salinity; //datachain += ";";   // si fonction de calcul de salinité uniquement
        }

        // print datachain
        if (debug_mode==1) {
          Serial.print("DATACHAIN COMPLETE:"); 
          Serial.println(datachain);
        }

    
      // record datachain on SD card
        File dataFile = SD.open(dataFilename, FILE_APPEND);
        if (dataFile) {                                        // if the file is available, write to it:
          dataFile.println(datachain);
          dataFile.close();
          if (debug_mode==1) Serial.println("ok : Datachain saved on SD card !");
        }
        else {                                                 // if the file isn't open, pop up an error:
          if (debug_mode==1) Serial.println("error opening file");
          for (int i=0; i<=5; i++){
              errormessage_sd();
          }
        }
        delay(200);

      // Sleeping of sensors and other
        all_sleep();
        
  } // End of the loop programm
  
  
  // entre esp32 into sleep mode
  if(debug_mode==1) Serial.println(" --> Going to sleep");

  esp_sleep_enable_timer_wakeup(TIME_TO_SLEEP * uS_TO_S_FACTOR);
  esp_deep_sleep_start();

}


void loop() {
 //never use because of the sleeping of the princess esp32
}




/////////////////////////////////////////////////////////////////
//              FONCTIONs de gestions des sensors
/////////////////////////////////////////////////////////////////

void mesure_pressure() {                              // fonction mesure de la pression et température sur le capteur blue robotics

  // Update pressure and temperature readings
  sensor_bar30.read();

  wat_pressure = sensor_bar30.pressure();
  wat_temp = sensor_bar30.temperature();
  wat_depth = sensor_bar30.depth();
  alt = sensor_bar30.altitude();

  if (debug_mode==1) {
    Serial.println("--- Pressure Sensor :");
    Serial.print("Pressure: ");
    Serial.print(wat_pressure);
    Serial.println(" mbar");
  
    Serial.print("Temperature: ");
    Serial.print(wat_temp);
    Serial.println(" deg C");
  
    Serial.print("Depth: ");
    Serial.print(wat_depth);
    Serial.println(" m");
  
    Serial.print("Altitude: ");
    Serial.print(alt);
    Serial.println(" m above mean sea level");
  }
}


void mesure_temp(){
  sensor_fastTemp.read();
  fast_temp = sensor_fastTemp.temperature();
  delay(200);
  if (debug_mode==1) {
    Serial.print("Température : ");
    Serial.print(fast_temp);
    Serial.println(" dec C");
  }
}



void all_sleep(){
      digitalWrite(greenled, LOW);
      digitalWrite(start12v, LOW); 
      delay(300);                            // on laisse le temps au régulateur de bien s'éteindre avant de passer en deep sleep
}


void mes_serial_sensor() {
  //Flush data
  while (Serial_fluo.available())
    Serial_fluo.read();

  //Clear last incomplete data
  char inByte = ' ';
  while (inByte != '\n') {
    if (Serial_fluo.available())
      inByte  = Serial_fluo.read();
  }

  //Fill data in string
  dataserial = "";
  char inByte2 = ' ';
  while (inByte2 != '\n') {
    if (Serial_fluo.available()) {
      inByte2  = Serial_fluo.read();
      dataserial += inByte2;
    }
  }

  Serial.print("dataserial 2 : "); Serial.println(dataserial); // juste pour voir la valeur de dataserial
}


  
void parse_serial_data(){    // pour paser la chaine du capteur Andera qui à des symbole bizarre comme séparateur et non pas des ","
  //----------------- parsing and filtering  data ---------------------
  // Dans la suite on filtre et on éclate les valeurs de datachain issu du capteur de fluo et on les formats dans une chaine "fluchain", et c'est fluochain qu'on ajoute à la datachain total

  full_serialFinal = "";
  short_serialFinal = "";

  //Serial.println(" Parsing data :");
  int fluo_length= dataserial.length();
  char fluochar_temp[fluo_length];
  char fluochar[fluo_length];

  dataserial.toCharArray(fluochar_temp, fluo_length);  // converti les string dataserial en tableau char (necessaire pour la fonction strtok)

  // filtration de valeur de texte V (on profite que c'est un table pour extraire les valeurs que l'on ne veut pas...
  for (int i = 0; i < fluo_length; i++){
    char temp = fluochar_temp[i];
    if (isDigit(temp) || temp == '.' || temp == ' ' || temp == '-'){
      fluochar[i] = temp;
    } else {
      fluochar[i] = ' ';
    }
  }

  Serial.print(" Filtered fluochar "); Serial.println(fluochar);

  int val1, val2;
  float val3, val4;

  // extrait les valeurs numériques de la chaîne
  int n = sscanf(fluochar, "%d %d %f %f", &val1, &val2, &val3, &val4);

  if (n == 4) {
    // toutes les valeurs ont été extraites avec succès
    full_serialFinal += String(val1) + ";" + String(val2) + ";" + String(val3, 3) + ";" + String(val4, 3);
    short_serialFinal += String(val3, 6) + ";" + String(val4, 6);

  }
  else {
    // erreur d'extraction
    full_serialFinal = "ERROR";
  }

  Serial.println("--- Serial Data Final :");
  Serial.print("Full_serialFinal :"); Serial.println(full_serialFinal);
  Serial.print("Short_serialFinal :"); Serial.println(short_serialFinal);
}




/////////////////////////////////////////////////////////////////
//                          FONCTION IHM
/////////////////////////////////////////////////////////////////

//void errormessage_bar(){
//  for (int i=0; i<=50; i++){                      // 50 * (50+50 ms) = 5000 ms = 5 seconde
//      digitalWrite(greenled, LOW);
//      delay(50);
//      digitalWrite(greenled, HIGH);
//      delay(50);
//  }
//}


void errormessage_sd(){
  for (int i=0; i <= 8; i++){                    // dans la boucle for il y a 1s, donc on a 8 seconde au total
      digitalWrite(greenled, HIGH); delay(400);
      digitalWrite(greenled, LOW); delay(50);
      digitalWrite(greenled, HIGH); delay(50);
      digitalWrite(greenled, LOW); delay(50);
      digitalWrite(greenled, HIGH); delay(50);
      digitalWrite(greenled, LOW); delay(50);
      digitalWrite(greenled, HIGH); delay(50);
      digitalWrite(greenled, LOW); delay (300);
  }
}


/////////////////////////////////////////////////////////////////
//                 FONCTIONS pour le datalogging
/////////////////////////////////////////////////////////////////


void lecture_rtc() {                          // fonction lecture de l'horloge RTC et ecriture dans les variables utilent
  
  int sec = Clock.getSecond();
  if (sec < 10) {
    second = String(0) + String(sec);
  }
  else {
    second = sec;
  }
  int minu = Clock.getMinute();
  if (minu < 10) {
    minute = String(0) + String(minu);
  }
  else {
    minute = minu;
  }
  int heure = Clock.getHour(h12, PM);
  if (heure < 10) {
    hour = String(0) + String(heure);
  }
  else {
    hour = heure;
  }
  int jour = Clock.getDate();
  if (jour < 10) {
    date = String(0) + String(jour);
  }
  else {
    date = jour;
  }
  int mois = Clock.getMonth(Century);
  if (mois < 10) {
    month = String(0) + String(mois);
  }
  else {
    month = mois;
  }
  year = Clock.getYear();
  datenum = ""; datenum += year; datenum += month; datenum += date;
  timenum = ""; timenum += hour; timenum += minute; timenum += second;
  datetime = ""; datetime += date; datetime += "/"; datetime += month; datetime += "/20"; datetime += year; datetime += " "; datetime += hour; datetime += ":"; datetime += minute; datetime += ":"; datetime += second;

  if (debug_mode==1) {
    Serial.println("--- RTC values :");
    Serial.print("Date :"); Serial.println(datenum);
    Serial.print("Time :"); Serial.println(timenum);
    Serial.print("DateTime"); Serial.println(datetime);
  }


}


// to initialize and test SD card
void test_sd(){
  if (debug_mode==1) Serial.print("-- Initializing SD card... :");   
  if (!SD.begin(cspin_SD)) {                      // // see if the card is present and can be initialized, ajouter ici chipSelect ou 5 pour la pin 5 par default
    if (debug_mode==1) Serial.println("Card failed, or not present");
    // don't do anything more:
    if (led_mode==1){
      //while(1) 
      errormessage_sd();
    }
  }
  if (debug_mode==1) Serial.println("card initialized.");    
}



void blinkled(int nbr, int freq) {   // freq en sec = freq interval between to light on
  for (int i=0; i<nbr; i++) {
    digitalWrite(greenled, HIGH); 
    delay(freq/2);
    digitalWrite(greenled, LOW);
    delay(freq/2);
  }
}


// lecture of the config file
void lecture_config(){
  confFile = SD.open(fichier_config, FILE_READ);

  char phrase[200];
  byte index = 0;
  char x=0;
  String reste = "";
  int k=0;
  
  if (confFile) {
    
    while (confFile.available()) {
      x = confFile.read();
      if (x!=10){
        if (x!=13) {
          phrase[index] = x;
          index++;
        } else {
          if (index != 0) {
            reste = phrase;
            reste = reste.substring(0,index);
            index=0;
            // suppression des commentaires
            k = reste.indexOf(";");
            if (k!=0) {
              if (k!=-1) {
                reste = reste.substring(0,k);
              }
              // supprime les espaces au début et à la fin
              reste.trim();
              //
              // extrait les valeurs pour les placer dans les variables du programme
              //
              if (reste.indexOf('=') >0) {
                // signe égal trouvé
                String clef = reste.substring(0,reste.indexOf('='));
                String valeur = reste.substring(reste.indexOf('=')+1);
                if (clef == "id_logger") id_logger = valeur;
                if (clef == "delay_batch") delay_batch = valeur;
                if (clef == "number_measures") number_measures = valeur;
                if (clef == "debug_mode") debug_mode_sd = valeur;
                if (clef == "led_mode") led_mode_sd = valeur;                        
                if (clef == "clef_test") clef_test = valeur;
              }
            }
          }          
        }
      }
     }
    // close the file:
    confFile.close();
  } else {
    // if the file didn't open, print an error:
    Serial.println("error opening "+fichier_config);
    while(1) errormessage_sd();
  }
}





// --------------------------------------------------------------------------------------------------
// --------------------- SERVER FUNCTIONS -----------------------------------------------------------
// --------------------------------------------------------------------------------------------------


void serveur() {
  
 //---------------------------------------------- SERVEUR
  //initSDCard();
 
  WiFi.softAP(ssid);
 
  Serial.println();
  Serial.print("IP address: ");
  Serial.println(WiFi.softAPIP());


  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send(SD, "/index.html", "text/html");
  });


  // Fonction du server pour modifier les valeurs du fichiers de configuration
  server.on("/get", HTTP_GET, [] (AsyncWebServerRequest *request) {
    inputMessage="";
    inputParam="";
    delayValue="";
    nbrValue="";
    ledValue="";
    debugValue="";

    int paramsNr = request->params();
    Serial.println(paramsNr);
 
    for(int i=0;i<paramsNr;i++){
 
        AsyncWebParameter* p = request->getParam(i);
        inputParam = p->name();
        inputMessage = p->value();
        Serial.print("Param name: ");
        Serial.println(inputParam);
        Serial.print("Param value: ");
        Serial.println(inputMessage);
        Serial.println("------");

        if (inputParam=="input1") {delayValue = inputMessage ;} 
        
        if (inputParam=="input2") {nbrValue = inputMessage ;}
        
        if (inputParam=="input3") {
          if(inputMessage=="1" or inputMessage=="0"){
            debugValue = inputMessage;
          }
          else {
             debugValue="1";
          }
        }
        
        if (inputParam=="input4") {
          if(inputMessage=="1" or inputMessage=="0"){
            ledValue = inputMessage;
          }
          else {
             ledValue="1";
          }
        }
    }

    createConfigFile();

    request->send(200, "text/html", "<html><head><link rel='stylesheet' type='text/css' href='style.css'></head><br><body class='bg'><h2>Ok - Values send to config file</h2><br><br><a href=\"/\"><button><h3>Return to Home Page<h3></button></a></body></html>");
    
  });

  // fonction du server pour afficher la page de résultat toute donnée effacé
  server.on("/erase", HTTP_GET, [](AsyncWebServerRequest *request) {
    eraseData();
    request->send(200, "text/html", "<html><head><link rel='stylesheet' type='text/css' href='style.css'></head><br><body class='bg'><h2>All data deleted</h2><br><br><a href=\"/\"><button><h3>Return to Home Page<h3></button></a></body></html>");
  });


  // fonction pour lire les valeurs de l'horloge de l'instrument
  
  server.on("/lireValue", HTTP_GET, [](AsyncWebServerRequest *request)
  {
    // lecture de l'horloge rtc
    lecture_rtc();
    request->send(200, "text/plain", datetime);
  });

  //server.on("/lireValue", HTTP_GET, [](AsyncWebServerRequest *request
 
  server.serveStatic("/", SD, "/");
  
  server.begin();

   //---------------------------------------------- /SERVEUR
  
}


void initSDCard(){
  if(!SD.begin(cspin_SD)){
    Serial.println("Card Mount Failed");
    return;
  }
  uint8_t cardType = SD.cardType();

  if(cardType == CARD_NONE){
    Serial.println("No SD card attached");
    return;
  }

  Serial.print("SD Card Type: ");
  if(cardType == CARD_MMC){
    Serial.println("MMC");
  } else if(cardType == CARD_SD){
    Serial.println("SDSC");
  } else if(cardType == CARD_SDHC){
    Serial.println("SDHC");
  } else {
    Serial.println("UNKNOWN");
  }
  uint64_t cardSize = SD.cardSize() / (1024 * 1024);
  Serial.printf("SD Card Size: %lluMB\n", cardSize);
}


void createConfigFile(){
  String dataString="";
  dataString += "id_logger="; dataString += id_logger; dataString += ";"; dataString += "\n";
  dataString += "delay_batch="; dataString += delayValue ; dataString += ";"; dataString += "\n";
  dataString += "number_measures="; dataString += nbrValue ; dataString += ";"; dataString += "\n";
  dataString += "debug_mode="; dataString += debugValue ; dataString += ";"; dataString += "\n";
  dataString += "led_mode="; dataString += ledValue ; dataString += ";"; dataString += "\n";

  // SD.remove(fichier_config);
  // delay(200);

  Serial.println(dataString);
  
  File dataFile = SD.open(fichier_config, FILE_WRITE);
    // if the file is available, write to it:
  if (dataFile) {
    dataFile.println(dataString);
    dataFile.close();
    // print to the serial port too:
    //Serial.println(dataString);
  }
  // if the file isn't open, pop up an error:
  else {
    Serial.println("error opening file");
  }

}


void eraseData() {
  String dataString="";

  File dataFile = SD.open(dataFilename, FILE_WRITE);
    // if the file is available, write to it:
  if (dataFile) {
    dataFile.println(dataString);
    dataFile.close();
    Serial.println("All data erased");
  }
  // if the file isn't open, pop up an error:
  else {
    Serial.println("error opening file");
  }

}